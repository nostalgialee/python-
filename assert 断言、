关于断言的意见有很多，因为它能确保代码的正确性。

如果你确定代码是正确的，那么就没有用断言的必要了，因为他们从来不会运行失败，你可以直接移除这些断言。
如果你确定检查会失败，那么如果你不用断言，代码就会通过编译并忽略你的检查。

一、好的使用断言的方式是检查程序的非变量。
一个非变量是一些你需要依赖它为真的情况，除非一个bug导致它为假。
如果有bug，最好能够尽早发现，所以我们为它进行一个测试，
但是又不想减慢代码运行速度。所以就用断言，因为它能在开发时打开，在产品阶段关闭。

        def some_function(arg):    
        ... 
        
        # code goes here

        assert not DB.closed()
       
        return result



二、断言也是一种防御型编程。你不是让你的代码防御现在的错误，而是防止在代码修改后引发的错误。
理想情况下，单元测试可以完成这样的工作，
可是需要面对的现实是，它们通常是没有完成的。人们可能在提交代码前会忘了运行测试代码。
有一个内部检查是另一个阻挡错误的防线，尤其是那些不明显的错误，却导致了代码出问题并且返回错误的结果。

        # target is expected to be one of x, y, or z, and nothing else
        
        if target == x:
            run_x_code()
        elif target == y:  
          run_y_code()
        else:
          run_z_code()

 假如上述代码发生修改，得到的 target == z 会发生什么，会关系到 run_z_code() 函数吗？
 加入修改代码后，没有修改此处代码导致错误的调用 run_z_code()函数并导致报错，可以使用防御型
 方法来写代码，可以使得代码执行正确或者立刻执行错误
        assert target in (x,y,z) # 防御型方法
 
        if target == x:
            run_x_code()
        elif target == y:  
          run_y_code()
        else:
          run_z_code()





三、按约定进行设计是断言的另一个好的用途。
我们想象函数与调用者之间有个约定，比如下面的：
“如果你传给我一个非空字符串，我保证传会字符串的第一个字母并将其大写。”
如果约定被函数或调用者破坏，代码就会出问题。
我们说函数有一些前置条件和后置条件，所以函数就会这么写：

        def first_upper(astring):
       
            assert isinstance(astring, str) and len(astring) > 0
            
            result = astring[0].upper()
      
            assert isinstance(result, str) and len(result) == 1
            assert result == result.upper()

            return result
按约定设计的目标是为了正确的编程，前置条件和后置条件是需要保持的。
这是断言的典型应用场景，
因为一旦我们发布了没有问题的代码到产品中，程序会是正确的，并且我们能安全的移除检查




下面是我建议的不要用断言的场景：

不要用它测试用户提供的数据
不要用断言来检查你觉得在你的程序的常规使用时会出错的地方。断言是用来检查非常罕见的问题。你的用户不应该看到任何断言错误，如果他们看到了，这是一个bug，修复它。
有的情况下，不用断言是因为它比精确的检查要短，它不应该是懒码农的偷懒方式。
不要用它来检查对公共库的输入参数，因为它不能控制调用者，所以不能保证调用者会不会打破双方的约定。
不要为你觉得可以恢复的错误用断言。换句话说，不用改在产品代码里捕捉到断言错误。
不要用太多断言以至于让代码很晦涩。






