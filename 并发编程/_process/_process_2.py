# -*- coding:utf-8 -*-
# @Time    : 2022/6/24 22:20
# @File    : _process_2.py
# Author: lee

# 守护进程

"""

守护进程
        1.背景：主进程语句执行完毕后，
        等待全部子进程结束后，主进程才结束 --- 回收子进程资源，否则产生僵尸进程


        2.守护进程
            # 本质： 一个子进程

            # 目的：守护主进程

            # 设置：
                p.daemon = True
                在 p.start() 之前设置

            # 结束：
                主进程代码执行完毕后，守护进程即结束 -- 被回收
                why: 1.本质是子进程，需要主进程回收资源

            # 注意：
                守护进程内不可开启子进程

            # 流程说明
                1.主进程代码执行完毕，守护进程结束被主进程回收
                2.子进程代码执行完毕、子进程结束、被主进程回收
                3.回收完所有的子进程资源后，主进程结束


        3.

        4.

"""

import os
import time
from multiprocessing import Process

class Myprocess(Process):

    def __init__(self, name):
        super().__init__()
        self.name = name

    def run(self):
        time.sleep(1)
        print('%s, 进程号: %d 执行完毕' % (self.name, os.getpid()))


if __name__ == "__main__":

    # **************************************************
    # 情况1：

    # p1 = Myprocess('子进程')
    # p1.start()
    #
    #
    # _p = Myprocess('守护进程')
    # _p.daemon = True #设置守护进程
    # _p.start()
    #
    #
    # print('主进程执行完毕 %d' % os.getpid())

    # 打印结果：
        # >>> 主进程执行完毕 12352
        # >>> 子进程, 进程号: 31768 执行完毕

    # 不打印 ：守护进程, 进程号: 32028 执行完毕
    # 因为在主进程的代码执行完毕之后，守护进程立刻被回收，不等待sleep完之后，直接回收

    # **************************************************
    # 情况2：

    p1 = Myprocess('子进程')
    p1.start()


    _p = Myprocess('守护进程')
    _p    .daemon = True  # 设置守护进程
    _p.start()
    p1.join()  # 阻塞主进程，等p1执行完之后再执行主进程

    print('主进程执行完毕 %d' % os.getpid())

    # 打印结果：
    # >>> 守护进程, 进程号: 20132 执行完毕
    # >>> 子进程, 进程号: 23836 执行完毕
    # >>> 主进程执行完毕 24428

    # 原因：
    #     p1.join() 之后，会等待 p1 进程执行完毕之后，再执行主进程
    #     守护进程此时也执行完毕，会等待主进程执行完毕后


